<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Carta del Restaurante</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background-color: #000000;
      color: #fff;
      font-family: 'Arial', sans-serif;
      overflow: hidden;
    }

    .pdf-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vw;
      position: relative;
    }

    #pdf-canvas {
      display: block;
    }

    .button {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 24px;
      color: #FFD700;
      background: none;
      border: none;
      cursor: pointer;
      z-index: 10;
      padding: 20px;
      user-select: none;
      transition: opacity 0.3s ease, transform 0.2s ease;
    }

    .button.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .left {
      left: 10px;
    }

    .right {
      right: 10px;
    }

    .button:not(.hidden):hover {
      transform: translateY(-50%) scale(1.1);
    }

    .button:not(.hidden):active {
      transform: translateY(-50%) scale(0.95);
    }
  </style>
</head>
<body>

<div class="pdf-container" id="pdf-container">
  <canvas id="pdf-canvas"></canvas>
  <button id="prev" class="button left hidden">&#10094;</button>
  <button id="next" class="button right">&#10095;</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
<script>
  const url = 'https://jesusalbertolopeztaipe-stack.github.io/SaborPeruano/CARTA.pdf';
  
  let pdfDoc = null;
  let currentPage = 1;
  let totalPages = 0;
  let startX = 0;
  let endX = 0;
  let isSwiping = false;
  let isRendering = false; // Prevenir renderizados simultáneos

  // Función para actualizar la visibilidad de las flechas
  function updateArrows() {
    const prevButton = document.getElementById('prev');
    const nextButton = document.getElementById('next');

    // Ocultar flecha izquierda en la primera página
    if (currentPage === 1) {
      prevButton.classList.add('hidden');
    } else {
      prevButton.classList.remove('hidden');
    }

    // Ocultar flecha derecha en la última página
    if (currentPage === totalPages) {
      nextButton.classList.add('hidden');
    } else {
      nextButton.classList.remove('hidden');
    }
  }

  // Función mejorada para calcular la escala óptima
  function getOptimalScale(page) {
    const container = document.getElementById('pdf-container');
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;

    // Obtener el viewport original del PDF
    const viewport = page.getViewport({ scale: 1 });
    const pageWidth = viewport.width;
    const pageHeight = viewport.height;

    // Calcular escalas basadas en el contenedor
    const scaleX = (containerWidth * 0.95) / pageWidth;
    const scaleY = (containerHeight * 0.95) / pageHeight;

    // Usar la escala menor para mantener la proporción
    return Math.min(scaleX, scaleY);
  }

  // Función para renderizar la página con alta calidad
  function renderPage(pageNum) {
    // Prevenir renderizados simultáneos
    if (isRendering) {
      return;
    }

    isRendering = true;

    pdfDoc.getPage(pageNum).then(function(page) {
      const canvas = document.getElementById('pdf-canvas');
      const ctx = canvas.getContext('2d');
      
      // Calcular la escala óptima
      const scale = getOptimalScale(page);
      const viewport = page.getViewport({ scale: scale });

      // Usar devicePixelRatio para alta resolución
      const dpr = window.devicePixelRatio || 1;

      // IMPORTANTE: Primero limpiar el canvas
      canvas.width = 0;
      canvas.height = 0;

      // Luego establecer los tamaños correctos
      const displayWidth = Math.floor(viewport.width);
      const displayHeight = Math.floor(viewport.height);

      // Establecer el tamaño real del canvas (resolución)
      canvas.width = displayWidth * dpr;
      canvas.height = displayHeight * dpr;

      // Establecer el tamaño visual del canvas (CSS)
      canvas.style.width = displayWidth + 'px';
      canvas.style.height = displayHeight + 'px';

      // Escalar el contexto para compensar el DPR
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      // Renderizar la página
      const renderContext = {
        canvasContext: ctx,
        viewport: viewport
      };

      page.render(renderContext).promise.then(function() {
        isRendering = false;
        updateArrows(); // Actualizar flechas después de renderizar
      }).catch(function(error) {
        console.error('Error al renderizar:', error);
        isRendering = false;
      });
    }).catch(function(error) {
      console.error('Error al obtener página:', error);
      isRendering = false;
    });
  }

  // Cargar el PDF
  pdfjsLib.getDocument(url).promise.then(function(pdf) {
    pdfDoc = pdf;
    totalPages = pdf.numPages;
    
    // Esperar un momento antes del primer renderizado para asegurar
    // que el DOM esté completamente listo
    requestAnimationFrame(function() {
      renderPage(currentPage);
    });
  }).catch(function(error) {
    console.error('Error al cargar el PDF:', error);
  });

  // Función para cambiar de página de forma segura
  function changePage(newPage) {
    if (isRendering) {
      return; // No cambiar si ya está renderizando
    }

    if (newPage >= 1 && newPage <= totalPages) {
      currentPage = newPage;
      renderPage(currentPage);
    }
  }

  // Navegación con botones
  document.getElementById('next').addEventListener('click', function() {
    changePage(currentPage + 1);
  });

  document.getElementById('prev').addEventListener('click', function() {
    changePage(currentPage - 1);
  });

  // Detectar gestos de deslizamiento en móvil
  const container = document.getElementById('pdf-container');

  container.addEventListener('touchstart', function(e) {
    startX = e.touches[0].clientX;
    isSwiping = true;
  }, { passive: true });

  container.addEventListener('touchmove', function(e) {
    if (!isSwiping) return;
    endX = e.touches[0].clientX;
  }, { passive: true });

  container.addEventListener('touchend', function(e) {
    if (isSwiping) {
      const swipeThreshold = 50;
      const diff = startX - endX;

      if (Math.abs(diff) > swipeThreshold) {
        if (diff > 0) {
          // Deslizar a la izquierda (siguiente página)
          changePage(currentPage + 1);
        } else {
          // Deslizar a la derecha (página anterior)
          changePage(currentPage - 1);
        }
      }
    }
    isSwiping = false;
  }, { passive: true });

  // Re-renderizar al cambiar el tamaño de la ventana
  let resizeTimeout;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
      if (pdfDoc && !isRendering) {
        renderPage(currentPage);
      }
    }, 250);
  });

  // Navegación con teclado
  document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight') {
      changePage(currentPage + 1);
    } else if (e.key === 'ArrowLeft') {
      changePage(currentPage - 1);
    }
  });
</script>

</body>
</html>
