<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Carta del Restaurante</title>
  <style>
    body, html {
      margin: 0;
      padding: 0;
      height: 100%;
      width: 100%;
      background-color: #000000;
      color: #fff;
      font-family: 'Arial', sans-serif;
      overflow: hidden;
    }

    .pdf-container {
      display: flex;
      justify-content: center;
      align-items: center;
      height: 100vh;
      width: 100vw;
      position: relative;
    }

    #pdf-canvas {
      display: block;
    }

    .button {
      position: absolute;
      top: 50%;
      transform: translateY(-50%);
      font-size: 24px;
      color: #FFD700;
      background: none;
      border: none;
      cursor: pointer;
      z-index: 10;
      padding: 20px;
      user-select: none;
      transition: opacity 0.3s ease, transform 0.2s ease;
    }

    .button.hidden {
      opacity: 0;
      pointer-events: none;
    }

    .left {
      left: 10px;
    }

    .right {
      right: 10px;
    }

    .button:not(.hidden):hover {
      transform: translateY(-50%) scale(1.1);
    }

    .button:not(.hidden):active {
      transform: translateY(-50%) scale(0.95);
    }
  </style>
</head>
<body>

<div class="pdf-container" id="pdf-container">
  <canvas id="pdf-canvas"></canvas>
  <button id="prev" class="button left hidden">&#10094;</button>
  <button id="next" class="button right">&#10095;</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.10.377/pdf.min.js"></script>
<script>
  const url = 'https://jesusalbertolopeztaipe-stack.github.io/SaborPeruano/CARTA.pdf';
  
  let pdfDoc = null;
  let currentPage = 1;
  let totalPages = 0;
  let startX = 0;
  let endX = 0;
  let isSwiping = false;
  let isRendering = false;
  let cachedPages = {}; // Cache para las páginas precargadas
  let cachedCanvases = {}; // Canvas precargados para cada página

  // Función para actualizar la visibilidad de las flechas
  function updateArrows() {
    const prevButton = document.getElementById('prev');
    const nextButton = document.getElementById('next');

    if (currentPage === 1) {
      prevButton.classList.add('hidden');
    } else {
      prevButton.classList.remove('hidden');
    }

    if (currentPage === totalPages) {
      nextButton.classList.add('hidden');
    } else {
      nextButton.classList.remove('hidden');
    }
  }

  // Función mejorada para calcular la escala óptima
  function getOptimalScale(page) {
    const container = document.getElementById('pdf-container');
    
    // Forzar recalculo del tamaño del contenedor
    const containerWidth = container.clientWidth;
    const containerHeight = container.clientHeight;

    // Si el contenedor no tiene dimensiones, usar window
    const width = containerWidth || window.innerWidth;
    const height = containerHeight || window.innerHeight;

    const viewport = page.getViewport({ scale: 1 });
    const pageWidth = viewport.width;
    const pageHeight = viewport.height;

    const scaleX = (width * 0.95) / pageWidth;
    const scaleY = (height * 0.95) / pageHeight;

    return Math.min(scaleX, scaleY);
  }

  // Función para precargar todas las páginas
  function preloadAllPages() {
    for (let i = 1; i <= totalPages; i++) {
      pdfDoc.getPage(i).then(function(page) {
        cachedPages[i] = page;
      }).catch(function(error) {
        console.error('Error precargando página ' + i + ':', error);
      });
    }
  }

  // Función para mostrar una página ya renderizada
  function displayCachedPage(pageNum) {
    if (isRendering) return;
    
    const cachedCanvas = cachedCanvases[pageNum];
    if (!cachedCanvas) {
      renderPage(pageNum);
      return;
    }

    isRendering = true;
    
    const canvas = document.getElementById('pdf-canvas');
    const ctx = canvas.getContext('2d');

    // Copiar el canvas cacheado
    canvas.width = cachedCanvas.width;
    canvas.height = cachedCanvas.height;
    canvas.style.width = cachedCanvas.style.width;
    canvas.style.height = cachedCanvas.style.height;

    ctx.drawImage(cachedCanvas, 0, 0);
    
    isRendering = false;
    updateArrows();
  }

  // Función para renderizar y cachear una página
  function renderAndCachePage(pageNum) {
    if (!cachedPages[pageNum]) {
      return;
    }

    const page = cachedPages[pageNum];
    const scale = getOptimalScale(page);
    const viewport = page.getViewport({ scale: scale });
    const dpr = window.devicePixelRatio || 1;

    const displayWidth = Math.floor(viewport.width);
    const displayHeight = Math.floor(viewport.height);

    // Crear canvas temporal para cachear
    const tempCanvas = document.createElement('canvas');
    const tempCtx = tempCanvas.getContext('2d');

    tempCanvas.width = displayWidth * dpr;
    tempCanvas.height = displayHeight * dpr;
    tempCanvas.style.width = displayWidth + 'px';
    tempCanvas.style.height = displayHeight + 'px';

    tempCtx.setTransform(dpr, 0, 0, dpr, 0, 0);

    const renderContext = {
      canvasContext: tempCtx,
      viewport: viewport
    };

    return page.render(renderContext).promise.then(function() {
      cachedCanvases[pageNum] = tempCanvas;
    });
  }

  // Función para renderizar la página con alta calidad
  function renderPage(pageNum) {
    if (isRendering) return;

    // Si ya está cacheada, mostrarla directamente
    if (cachedCanvases[pageNum]) {
      displayCachedPage(pageNum);
      return;
    }

    isRendering = true;

    const pagePromise = cachedPages[pageNum] 
      ? Promise.resolve(cachedPages[pageNum])
      : pdfDoc.getPage(pageNum);

    pagePromise.then(function(page) {
      const canvas = document.getElementById('pdf-canvas');
      const ctx = canvas.getContext('2d');
      
      const scale = getOptimalScale(page);
      const viewport = page.getViewport({ scale: scale });
      const dpr = window.devicePixelRatio || 1;

      const displayWidth = Math.floor(viewport.width);
      const displayHeight = Math.floor(viewport.height);

      canvas.width = displayWidth * dpr;
      canvas.height = displayHeight * dpr;
      canvas.style.width = displayWidth + 'px';
      canvas.style.height = displayHeight + 'px';

      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);

      const renderContext = {
        canvasContext: ctx,
        viewport: viewport
      };

      return page.render(renderContext).promise;
    }).then(function() {
      isRendering = false;
      updateArrows();
    }).catch(function(error) {
      console.error('Error al renderizar página:', error);
      isRendering = false;
    });
  }

  // Cargar el PDF
  pdfjsLib.getDocument(url).promise.then(function(pdf) {
    pdfDoc = pdf;
    totalPages = pdf.numPages;
    
    // Precargar todas las páginas en segundo plano
    preloadAllPages();
    
    // Esperar a que el layout esté listo antes del primer render
    setTimeout(function() {
      // Renderizar la primera página
      renderPage(currentPage);
      
      // Cachear las siguientes páginas después de un momento
      setTimeout(function() {
        for (let i = 1; i <= totalPages; i++) {
          if (cachedPages[i]) {
            renderAndCachePage(i);
          }
        }
      }, 500);
    }, 100);
  }).catch(function(error) {
    console.error('Error al cargar el PDF:', error);
  });

  // Función para cambiar de página de forma segura
  function changePage(newPage) {
    if (isRendering) {
      return; // No cambiar si ya está renderizando
    }

    if (newPage >= 1 && newPage <= totalPages) {
      currentPage = newPage;
      renderPage(currentPage);
    }
  }

  // Navegación con botones
  document.getElementById('next').addEventListener('click', function() {
    changePage(currentPage + 1);
  });

  document.getElementById('prev').addEventListener('click', function() {
    changePage(currentPage - 1);
  });

  // Detectar gestos de deslizamiento en móvil
  const container = document.getElementById('pdf-container');

  container.addEventListener('touchstart', function(e) {
    startX = e.touches[0].clientX;
    isSwiping = true;
  }, { passive: true });

  container.addEventListener('touchmove', function(e) {
    if (!isSwiping) return;
    endX = e.touches[0].clientX;
  }, { passive: true });

  container.addEventListener('touchend', function(e) {
    if (isSwiping) {
      const swipeThreshold = 50;
      const diff = startX - endX;

      if (Math.abs(diff) > swipeThreshold) {
        if (diff > 0) {
          // Deslizar a la izquierda (siguiente página)
          changePage(currentPage + 1);
        } else {
          // Deslizar a la derecha (página anterior)
          changePage(currentPage - 1);
        }
      }
    }
    isSwiping = false;
  }, { passive: true });

  // Re-renderizar al cambiar el tamaño de la ventana
  let resizeTimeout;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimeout);
    resizeTimeout = setTimeout(function() {
      if (pdfDoc && !isRendering) {
        renderPage(currentPage);
      }
    }, 250);
  });

  // Navegación con teclado
  document.addEventListener('keydown', function(e) {
    if (e.key === 'ArrowRight') {
      changePage(currentPage + 1);
    } else if (e.key === 'ArrowLeft') {
      changePage(currentPage - 1);
    }
  });
</script>

</body>
</html>
